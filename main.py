from __future__ import annotations
from core.sound.player import SoundManager
from core.sound.spotify import SpotifyController
from core.listen.listen import get_listen_manager
from core.config.manager import get_config_manager
from core.log_manager import init_new_session
import time
import threading
from core.interface import create_interface
from core.interface.window_manager import WindowManager
import argparse
from pathlib import Path
from dataclasses import dataclass
from typing import Any, Dict
import yaml
from PySide6 import QtCore, QtGui, QtWidgets
from pprint import pprint
from core.bus import EventBus
from core.vocalizer import Vocalizer
from core.sound.fx_event_handler import init_fx_event_handler
from core.lexique.manager import get_lexique_manager
import queue  # Pour les exceptions queue.Empty
import signal
import sys
from core.pol import create_pol
pol = create_pol(source_id=1)

# ‚úÖ Variables globales
bus = EventBus()
listen_started = False
config = None  # ‚Üê D√©clarer config globalement
sm = None      # ‚Üê D√©clarer sm globalement
#fx_handler = init_fx_event_handler(bus)
lexique = get_lexique_manager()
# --- callback √©v√©nements ---
def on_bus_message(msg):
    global sm  # ‚úÖ Utiliser l'instance globale sm (pas sound_manager)
    
    name = msg["name"]
    state = msg["state"]
    payload = msg.get("payload", {})

    # ========== FILTRAGE DES MESSAGES VERBEUX ==========
    # Masquer les messages Spotify trop fr√©quents pour √©viter le spam
    if name == "spotify" and state in ["playback", "playing","app_check", "paused","polling","volume_command","device_scan","command_success"]:
        return  # On ignore ces messages, pas d'affichage
    
    # Masquer les messages debug de listen (trop verbeux)
    if name == "listen.main_listener" and state == "debug":
        return  # On ignore ces messages debug
    
    # ‚úÖ NOUVEAU : Filtrer les √©v√©nements de volume qui spamment
    if name == "volume" and state in ["music_changed", "journal_changed", "info_changed", "master_changed"]:
        return
    
    # ‚úÖ NOUVEAU : Filtrer les √©v√©nements duck trop fr√©quents
    if name == "duck" and state in ["on", "off"]:
        return
    
    # ‚úÖ NOUVEAU : Filtrer les √©v√©nements audio de routine
    if name in ["info", "music", "journal"] and state in ["low_enqueued", "low_started", "low_finished"]:
        return
    
    if name == "listen.main_listener" and state == "started":
        listen_started = True

    #pour les test audio de la config
    if name == "audio.play_file" and state == "request":
        pol.write(1, "üîä Test audio en cours...", "log")
        if sm:  # ‚úÖ Utiliser sm au lieu de SoundManager
            # Utiliser la priorit√© info (basse) comme dans la doc
            sm.info.play(payload.get("file", ""), priority="low")
        else:
            pol.write(3, "‚ùå SoundManager non initialis√©", "log+print")
    elif name == "audio.play_file" and state == "success":
        pol.write(1, "‚úÖ Test audio r√©ussi", "log")
    elif name == "audio.play_file" and state == "error":
        pol.write(3, "‚ùå Erreur lors du test audio", "log+print")

    # Traitement sp√©cial pour les reconnaissances vocales
    if name == "listen.main_listener" and state == "recognition":
        
        data = payload.get("data", {})
        
        # ‚úÖ CORRECTION √âCHELLE : Listen renvoie 0-1, config stocke 0-100
        confidence_received = data.get("confidence", 0)  # 0-1 (ex: 0.85)
        confidence_threshold_config = config.get("listen.Confidence", 50)  # 0-100 (ex: 50)
        
        # Convertir le seuil de config (0-100) vers l'√©chelle listen (0-1)
        confidence_threshold = confidence_threshold_config / 100.0  # ex: 50 -> 0.5
        
        if confidence_received < confidence_threshold:
            # ‚úÖ PROTECTION : V√©rifier que data et options existent
            options = data.get("options")
            if options is None:
                action_detected = "donn√©es_manquantes"
            else:
                action_detected = options.get("action", "commande_inconnue")
            pol.write(2, f"üé§ Commande rejet√©e '{action_detected}' (confiance trop basse: {confidence_received:.2f} < {confidence_threshold:.2f})", "log")
            pol.write(2, f"üé§ COMMANDE REJET√âE '{action_detected}' (confiance trop basse)", "log")
            pol.write(2, f"üí° Confiance re√ßue: {confidence_received:.2f} ({confidence_received*100:.0f}%)", "log")
            pol.write(2, f"üí° Seuil requis: {confidence_threshold:.2f} ({confidence_threshold_config}%)", "log")
            return
        pol.write(2, f"üé§ Commande accept√©e (confiance suffisante: {confidence_received:.2f} >= {confidence_threshold:.2f})", "log")
        pol.write(1, f"‚úÖ Confiance OK: {confidence_received:.2f} ({confidence_received*100:.0f}%) >= {confidence_threshold:.2f} ({confidence_threshold_config}%)", "log")
        pol.write(1, f"üé§ COMMANDE RECONNUE (COMPLET):", "log")

        # ‚úÖ PROTECTION : V√©rifier que options existe avant de l'utiliser
        options = data.get("options")
        if options is None:
            pol.write(3, "‚ö†Ô∏è Aucune option trouv√©e dans les donn√©es de reconnaissance", "log+print")
            action_detected = "options_manquantes"
        else:
            action_detected = options.get("action", "action_manquante")
        # R√©cup√©rer l'action dans le lexique
        action = lexique.get_action(action_detected)
        random_response = lexique.get_random_response(action_detected)
        
        pol.write(1, f"üé§ COMMANDE RECONNUE: {action_detected}", "log")
        pol.write(1, f"üí¨ R√©ponse al√©atoire: {random_response}", "log")
        pol.write(1, f"üóÇÔ∏è effect: {config.get('vocalisation.effect', 'none')}", "log")
        action_event = {
            "name": "tts.speak",
            "state": "request",
            "payload": {
                "engine": config.get("vocalisation.engine", "edgetts"),
                "action": action_detected, 
                "text": random_response,
                #"effect": action.effect if action else config.get("vocalisation.default_effect", "none"),
                "effect": config.get("vocalisation.effect", "none"),
                "play_now": True
            }
        }
        bus.publish(action_event)
        return

    # Afficher tous les autres messages normalement
    print("[MAIN] Event:", name, state, payload)

    if name == "tts.speak" and state == "request":
        pol.write(1, "üéµ Demande TTS via bus...", "log")
        
        # Cr√©er une instance VCZ
        from core.vocalizer import Vocalizer
        vcz = Vocalizer(config, bus)
           
        # Extraire les param√®tres
        engine = payload.get("engine", "piper")
        action = payload.get("action", "default")
        text = payload.get("text", "Test")
        effect = payload.get("effect", "none")
        play_now = payload.get("play_now", True)

        pol.write(1, f"üé§ TTS: {engine}/{action} - '{text[:30]}...'", "log")

        # ‚úÖ D√©l√©guer au VCZ (qui publiera audio.play_file si succ√®s)
        result = vcz.create(engine, action, text, effect, play_now)
    
    if name == "info.high.started":
        pol.write(1, "Info HIGH d√©marr√©e, musique et journal stopp√©s.", "log")
        # ex : LED bureau rouge + baisse Spotify
        # hue.set_color("red")
        # spotify.lower_volume()
        pass
    elif name == "duck.on":
        # si un autre lecteur est actif, baisse-le aussi
        pass
    elif name == "duck.off":
        # remonte le volume externe
        pass

    # ‚úÖ NOUVEAU : Gestion des √©v√©nements FX Generator
    if name == "fx.generate_effect" and state == "request":
        pol.write(1, "üéõÔ∏è Demande g√©n√©ration effet via bus...", "log")
        
        # Lazy import pour √©viter les d√©pendances circulaires
        from core.sound.fx_generator import fx_generator
        
        # Extraire les param√®tres
        source_path = payload.get("source_path", "")
        effect_type = payload.get("effect_type", "")
        priority_str = payload.get("priority", "normal")
        force_remake = payload.get("force_remake", False)
        requester = payload.get("requester", "unknown")
        
        # Convertir priorit√© string ‚Üí enum
        from core.sound.fx_generator import Priority
        priority_map = {
            "low": Priority.LOW,
            "normal": Priority.NORMAL, 
            "high": Priority.HIGH,
            "urgent": Priority.URGENT
        }
        priority = priority_map.get(priority_str, Priority.NORMAL)
        
        pol.write(1, f"üéõÔ∏è G√©n√©ration effet {effect_type} (priorit√©: {priority_str}, source: {requester})", "log")

        # D√©clencher g√©n√©ration asynchrone
        success = fx_generator.create_async(source_path, effect_type, force_remake, priority)
        
        if success:
            pol.write(1, f"‚úÖ Effet {effect_type} programm√©", "log")
        else:
            pol.write(3, f"‚ùå Erreur programmation effet {effect_type}", "log+print")

    elif name == "fx.generate_all_variants" and state == "request":
        pol.write(1, "üéõÔ∏è Demande g√©n√©ration toutes variantes via bus...", "log")
        
        # Lazy import pour √©viter les d√©pendances circulaires
        from core.sound.fx_generator import fx_generator, Priority
        
        # Extraire les param√®tres
        source_path = payload.get("source_path", "")
        effects = payload.get("effects", [])
        priority_str = payload.get("priority", "low")
        force_remake = payload.get("force_remake", False)
        requester = payload.get("requester", "unknown")
        
        # Convertir priorit√©
        priority_map = {
            "low": Priority.LOW,
            "normal": Priority.NORMAL,
            "high": Priority.HIGH, 
            "urgent": Priority.URGENT
        }
        priority = priority_map.get(priority_str, Priority.LOW)
        
        pol.write(1, f"üéõÔ∏è G√©n√©ration toutes variantes {effects} (priorit√©: {priority_str}, source: {requester})", "log")

        # Programmer chaque effet
        programmed = 0
        for effect in effects:
            if fx_generator.create_async(source_path, effect, force_remake, priority):
                programmed += 1

        pol.write(1, f"‚úÖ {programmed}/{len(effects)} variantes programm√©es", "log")

# ‚úÖ Corriger la fonction async
def start_listen_manager_async():
    """D√©marre le listen manager de fa√ßon asynchrone"""
    global config  # ‚úÖ Utiliser la variable globale
    try:
        print("üé§ D√©marrage du listen manager...")
        listen_mgr = get_listen_manager(bus, config.get_section("listen").get("debug", False))
        options = config.get_section("listen")
        listen_mgr.start("main_listener", options)
        print("‚úÖ Listen manager d√©marr√© avec succ√®s")
    except Exception as e:
        print(f"‚ùå Erreur lors du d√©marrage du listen manager: {e}")
        import traceback
        traceback.print_exc()

def main():
    global config, sm, lexique, window_manager  # ‚úÖ Ajouter window_manager
    
    # ‚úÖ PREMI√àRE CHOSE : Rotation des logs (avant tout autre traitement)
    init_new_session()
    #pol = create_pol(source_id=1)
    pol.write(1, "üöÄ D√©marrage d'Orion...", "log+print")  # LEGER + console
    
    sm = SoundManager(event_bus=bus)
    
    # Cr√©er l'application Qt
    app = QtWidgets.QApplication([])
    
    # ‚úÖ NOUVEAU : Gestionnaire de signal pour Ctrl+C
    def signal_handler(sig, frame):
        pol.write(1, "üõë Interruption d√©tect√©e (Ctrl+C)", "log")
        #print("\nüõë Interruption d√©tect√©e (Ctrl+C)")
        pol.write(1, "üîÑ Arr√™t en cours...", "log")
        #print("üîÑ Arr√™t en cours...")
        
        # Arr√™ter proprement les composants
        try:
            if sm:
                pol.write(1, "üîä Arr√™t SoundManager...", "log")
                #print("üîä Arr√™t SoundManager...")
                sm.stop_all()

            pol.write(1, "üö™ Fermeture application...", "log")
            #print("üö™ Fermeture application...")
            app.quit()  # Fermer l'application Qt
            
        except Exception as e:
            pol.write(3, f"‚ö†Ô∏è Erreur lors de l'arr√™t: {e}", "log")
            #print(f"‚ö†Ô∏è Erreur lors de l'arr√™t: {e}")

        pol.write(1, "üëã Au revoir !", "log")
        sys.exit(0)
    
    # ‚úÖ INSTALLER le gestionnaire de signal
    signal.signal(signal.SIGINT, signal_handler)  # Ctrl+C
    signal.signal(signal.SIGTERM, signal_handler)  # Termination
    
    # ‚úÖ IMPORTANT : Timer pour traiter les signaux dans Qt
    timer = QtCore.QTimer()
    timer.start(100)  # V√©rifier les signaux toutes les 100ms
    timer.timeout.connect(lambda: None)  # Permet √† Python de traiter les signaux
    
    # ‚úÖ Cr√©er le gestionnaire de configuration et l'assigner √† la variable globale
    config = get_config_manager(bus)
    
    # ‚úÖ Passer config au lexique pour hotword
    lexique.set_config_manager(config)
    
    # ‚úÖ Maintenant on peut faire update_SRGS
    pol.write(1, "üéôÔ∏è G√©n√©ration des grammaires SRGS...", "log")
    if not lexique.update_SRGS(force=True):
       pol.write(3, "‚ö†Ô∏è Probl√®me avec la g√©n√©ration des grammaires, continuons...", "log+print")

    # ‚úÖ Cr√©er le gestionnaire de fen√™tres AVEC la config
    from core.interface.window_manager import WindowManager
    window_manager = WindowManager(config_manager=config)
    
    # ‚úÖ Cr√©er l'interface principale (SANS window_manager)
    interface = create_interface(bus, config)
    
    # ‚úÖ G√©rer la position avec window_manager APR√àS cr√©ation
    window_manager.get_screen_info()
    
    # ‚úÖ Restaurer la position avant d'afficher
    position_restored = window_manager.restore_window_state(interface, "orion_main")
    if not position_restored:
        # Position par d√©faut sur l'√©cran secondaire si disponible
        screens = app.screens()
        if len(screens) > 1:
            # Placer sur le deuxi√®me √©cran
            secondary_screen = screens[1]
            geometry = secondary_screen.geometry()
            interface.move(geometry.x() + 100, geometry.y() + 100)
            pol.write(1, f"üìç Positionnement sur √©cran secondaire: {geometry.x() + 100}, {geometry.y() + 100}", "log")
    
    # Afficher l'interface
    interface.show()
    
    # ‚úÖ Connecter la sauvegarde √† la fermeture
    def on_close(event):
        pol.write(1, "üíæ Sauvegarde de la position de fen√™tre...", "log")
        window_manager.save_window_state(interface, "orion_main")
        event.accept()
    
    # ‚úÖ Connecter l'√©v√©nement de fermeture proprement
    interface.closeEvent = on_close

    pol.write(1, "‚úÖ Interface cr√©√©e et positionn√©e", "log")

    # --- abonnement aux √©v√©nements ---
    bus.subscribe(on_bus_message)

    # ‚úÖ D√âMARRAGE ASYNCHRONE du listen manager (pas de freeze de l'interface)
    listen_thread = threading.Thread(target=start_listen_manager_async, daemon=True)
    listen_thread.start()

    # ‚ùå SUPPRIMER CES LIGNES :
    # Dans une autre partie du code
    # vcz = Vocalizer(config, bus)
    # vcz.create("piper", "start_orion", "Bonjour je suis votre copilote Orion", "none", True)

    # Dans ton code principal
    #vcz.create("edgetts", "test", "Bonjour Star Citizen", "none", True)

    # ‚úÖ REMPLACER PAR un √©v√©nement via bus (optionnel) :
    def send_startup_greeting():
        """Envoie un message d'accueil apr√®s d√©marrage"""
        time.sleep(2)  # Attendre 2 secondes apr√®s d√©marrage
        
        # ‚úÖ NOUVEAU : R√©cup√©rer le message d'accueil personnalis√© depuis la config
        welcome_message = config.get("vocalisation.welcome", "Bonjour, je suis votre copilote Orion. Syst√®me en cours de d√©marrage.")
        
        startup_event = {
            "name": "tts.speak",
            "state": "request",
            "payload": {
                "engine": config.get("vocalisation.engine", "edgetts"),
                "action": "start_orion", 
                "text": welcome_message,  # ‚úÖ Utiliser le message personnalis√©
                "effect": config.get("vocalisation.effect", "none"),
                "play_now": True
            }
        }
        bus.publish(startup_event)
        
        pol.write(1, "üé§ Message d'accueil envoy√© via bus", "log")

    # Lancer le message d'accueil en thread (optionnel)
    greeting_thread = threading.Thread(target=send_startup_greeting, daemon=True)
    greeting_thread.start()

    # ‚úÖ Boucle principale Qt
    pol.write(1, "üöÄ Interface lanc√©e - Listen manager en cours de d√©marrage...", "log+print")
    pol.write(1, "üí° Utilisez Ctrl+C pour arr√™ter l'application", "log")

    try:
        exit_code = app.exec()
    except KeyboardInterrupt:
        pol.write(3, "üõë Interruption clavier d√©tect√©e", "log+print")
        signal_handler(signal.SIGINT, None)

    pol.write(1, "üëã Au revoir !", "log+print")
    exit(exit_code)

if __name__ == "__main__":
    main()

